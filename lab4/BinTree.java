package lab4;//// BinTree class//// this class implements a binary tree//// the tree is unbounded. fields are//     info: the value stored in the node (generic type)//     left:   pointer to the left subtree//     right:  pointer to the right subtree//     parent: pointer to the parent//     preOrderQueue: queue of nodes for preorder traversal//// left, right, and parent are public to allow the client code// to manipulate the tree as needed//// methods://     constructor to create empty tree//     constructor to create tree with one node//     constructor to create tree given the root value, and//          pointers to the left and right subtrees//     get and set methods for the info field//     isEmpty//     attachLeft:  if there is no left child, attach the given tree as//                  the new left child; otherwise throw TreeViolationException//     attachRight: if there is no right child, attach the given tree as//                  the new right child; otherwise throw TreeViolationException//     detachLeft:  detach and return the left child//     detachRight: detach and return the right child//     root:        return the root of the treepublic class BinTree<T> implements BinTreeInterface<T> {	protected T info;    public BinTree<T> left;    public BinTree<T> right;    public BinTree<T> parent;	private LinkedQueue<T> preOrderQueue;    public BinTree() {	    info = null;        left = null;        right = null;        parent = null;    }    public BinTree(T item) {        info = item;        left = null;        right = null;        parent = null;    }    public BinTree(T item, BinTree<T> ltree, BinTree<T> rtree) {        info = item;        parent = null;        if (ltree != null) {            left = ltree;            ltree.parent = this;        }        else            left = null;        if (rtree != null) {            right = rtree;            rtree.parent = this;        }        else            right = null;    }    public T getInfo() {        return info;    }    public void setInfo(T newitem) {        info = newitem;    }	public boolean isEmpty() {		return info == null;	}    public void attachLeft(BinTree<T> tree) {        if (left == null && tree != null) {            left = tree;            tree.parent = this;        }        else            throw new TreeViolationException("attachLeft: left subtree already exists");    }    public void attachRight(BinTree<T> tree) {        if (right == null && tree != null) {            right = tree;            tree.parent = this;        }        else            throw new TreeViolationException("attachRight: right subtree already exists");    }	public BinTree<T> detachLeft() {		BinTree<T> retLeft = left;		left = null;		return retLeft;	}	public BinTree<T> detachRight() {		BinTree<T> retRight = right;		right = null;		return retRight;	}	public BinTree<T> root() {		// this is the root		if (parent == null)			return this;		// follow parent links up to the root		BinTree<T>nextParent = parent;		while (nextParent.parent != null)			nextParent = nextParent.parent;		return nextParent;	}  // Initializes preOrderQueue with tree elements in preOrder order.    public void preOrder(BinTree<T> tree)  {        if (tree != null) {            preOrderQueue.enqueue(tree.getInfo());            preOrder(tree.left);            preOrder(tree.right);        }    }	// calls preorder to create queue of nodes in the tree    public void reset()  {      preOrderQueue = new LinkedQueue<T>();      preOrder(this);  }    // removes and returns the next node in the preorder queue    // returns null if the queue is empty    public T getNext()  {		if (preOrderQueue.isEmpty())			return null;		else			return preOrderQueue.dequeue();    }}